<?php
/**
 * Clase que gestiona las Incidencias.
 * 
 * @package Core
 * @version 0.1
 * @author 
 * Juan Ramón González Hidalgo
 * 
 * Antonio Irlandés García
 */
 class Validar{
	 
	/**
	 * Constructor
	 */	
	public function __construct(){}

	/**
	 * Validación de fechas.
	 * 
	 * @param string $fecha Fecha en formato "dd/mm/aaaa"
	 */
	public function fecha($data){

		$valido = false;
	  	//patrón: dd/mm/aaaa
	  	$regexp = "^([[:digit:]]{1,2})/([[:digit:]]{1,2})/([[:digit:]]{2,4})$";
	  	
	  	if(!eregi($regexp, $data))
	  		return false;
	  	else{
	  		//comprobamos los rangos de los números
	  		$fecha = array();
	  		$fecha = explode("/", $data);
	  		$dia = $fecha[0];
	  		$mes = $fecha[1];
	  		$anyo = $fecha[2];
	  	
	  		if($mes<1 || $mes>12 || $dia<1)
	  			return false;
	  		
	  		switch($mes){
	  			case 1:
	  			case 3:
	  			case 5:
	  			case 7:
	  			case 8:
	  			case 10:
	  			case 12:
	  				if($dia <= 31)
	  					$valido = true;
	  				break;
	  			case 2:
	  				//comprobar anyo bisiesto:
	  				$bisiesto = false;
	  				
	  				//si es divisible por 4, 100 y 400, es bisiesto
	  				//si es divisible por 4, 100 pero no por 400, no es bisiesto
	  				//si es divisible por 4 y no por 100, es bisiesto
	  				$r4 = fmod($anyo, 4);
	  				$r100 = fmod($anyo, 100);
	  				$r400 = fmod($anyo, 400);
	  				
	  				if($r4 != 0)
	  					$bisiesto = false;
	  				else if($r100 != 0)
	  					$bisiesto = true;
	  				else if($r100 == 0 && $r400 != 0)
	  					$bisiesto = false;
	  				else if($r100 == 0 && $r400 == 0)
	  					$bisiesto = true;

	  				if($bisiesto){
	  					if($dia<=29)
	  						$valido = true;
	  				}
	  	  			else if($dia<=28){
	  						$valido = true;
	  	  			}
	  				break;
	  			case 4:
	  			case 6:
	  			case 9:
	  			case 11:
	  				if($dia<=30)
	  					$valido = true;
	  				break;
	  		}
	  	}//fin else

	  		
	  	return $valido;
	}
	  
 	/**
	 * Validación de identificador genérico (Entero de hasta 11 dígitos)
	 * 
	 * @param integer $data Identificador genérico
	 */
	public function id($data){
		$valido = false;
		//8 dígitos máximo, 2 como mínimo
		$regexp = "^[[:digit:]]{1,11}$";
		 	
		if(is_numeric($data) && eregi($regexp, $data))
			$valido = true;
		 		
		return $valido;  	
	 }
	  
 	/**
 	 * Validación de cualquier cadena de búsqueda sin patrón definido.
	 * 
	 * @param string $data Cadena a validar.
 	 */
 	public function cadena($data){
 		$valido = false;
 		
 		//expresion regular con la lista de caracteres permitidos:
 		$regexp = "[^[:alnum:]áéíóúÁÉÍÓÚ _.,:;ñÑºª@ü()'\"/-]+<>";
 		
	 	if(!eregi($regexp, $data))
	  		$valido = true;
	
	  	if($valido==false)
	  		$this->error=true;
	  		
		return $valido;	
 	}
 	
  	/**
 	 * Validación de la contraseña.
	 * 
	 * Por limitaciones en el flujo del programa, en el punto donde se hace el login
	 * no está disponible la función mysql_real_escape_string(), con lo cual hay que tener
	 * especial cuidado..
	 * 
	 * @param string $data Cadena a validar.
 	 */
 	public function passwd($data){
 		$valido = false;
 		
 		//expresion regular con la lista de caracteres permitidos:
 		//Al ser el password autogenerado, el conjunto de caracteres se limita a los alfanuméricos.
 		$regexp = "[^[:alnum:]]+";
 		
	 	if(!eregi($regexp, $data))
	  		$valido = true;
	
	  	if($valido==false)
	  		$this->error=true;
	  		
		return $valido;	
 	} 	
 	
 	/**
	 * Convierte a timestamp una fecha en el formato dd/mm/aa.
	 * 
	 * @param string $date Fecha en formato dd/mm/aaaa
	 */
	public function date2timestamp($date){
		$tmp = @explode("/", $date);
		return @mktime(0,0,0,$tmp[1], $tmp[0], $tmp[2]);
	}
	
 	/*
	 * Validamos los datos que deben ser email's
	 * 
	 * @param string $email Cadena con una dirección de e-mail.
	 */
	public function email($email){
		if(eregi("^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,3})$", $email)) 
			return true;
		else
			return false;
	
	}
	
	/**
	 * Validación de teléfono fijo
	 * @param integer $data
	 */
	function telefono($data){
	  	$valido = false;
	  	//Empieza por 9, luego 8 dígitos
	  	$regexp = "^(9|8){1}[0-9]{8}$";
	  	//O es un corporativo
	  	$regexp_corp = "^[0-9]{6}$";
	  	
	  	if(eregi($regexp, $data) || eregi($regexp_corp, $data))
	  		$valido = true;
	
	  	if($valido==false) $this->error=true;
	  	if($data == '') $valido=true;
		return $valido;  					
	 }
	 /**								
 	 * Validación de teléfono móvil
 	 * @param integer $data
 	 */
 	function movil($data){
 	  	$valido = false;
	  	//Empieza por 6, luego 8 dígitos
	  	$regexp = "^6{1}[0-9]{8}$";
	  	//También hay móviles corporativos...
	  	$regexp_corp = "^[0-9]{6}$";
	  	
	  	if(eregi($regexp, $data) || eregi($regexp_corp, $data))
	  		$valido = true;
	
	  	if($valido==false) $this->error=true;
		return $valido;  					
 	}
	
	/**
	 * Se encarga de limpiar las etiquetas no permitidas y los atributos
	 * de las etiquetas permitidas.
	 * 
	 * @param string $html Texto html que se desea limpiar
	 * @param string $etiquetas img,a,p,span ...etc
	 * @param string $atributos href,style,src ...etc
	 * 
	 * @return string $html Código html limpio.
	 */
	public function clean_html($html,$etiquetas,$atributos) {
		
		//Comprobamos si existe una lista de etiquetas no permitidas
		//para ser borradas
		if($etiquetas!=""){
			$etiquetas = str_replace("," , "|" ,$etiquetas);
			$html = ereg_replace("<(/)?(".$etiquetas.")[^>]*>","",$html);
		}
		//Comprobamos si existe una lista de atributos no permitidos
		if($atributos!=""){
			$atributos = str_replace("," , "|" ,$atributos);
			// then run another pass over the html (twice), removing unwanted attributes <<<---- Si hay que hacerlo 2 veces, no me preguntes porque...
			$html = ereg_replace("<([^>]*)(".$atributos.")=(\"[^\"]*\"|'[^']*'|[^>]+)([^>]*)>","<\\1>",$html);
			$html = ereg_replace("<([^>]*)(".$atributos.")=(\"[^\"]*\"|'[^']*'|[^>]+)([^>]*)>","<\\1>",$html);
		}
		return $html;  
	}

} 
?>
